##########################################################################################
# Tool: Fusion Compiler
# Script: Makefile_pnr.discrete_fp_steps
# Version: V-2023.12-SP4
# Copyright (C) 2014-2024 Synopsys, Inc. All rights reserved.
##########################################################################################

FC_EXEC = fc_shell 
FM_EXEC = fm_shell
VC_LP_EXEC = vc_static_shell
OPTIONS =

## LOGS_DIR value comes from rm_setup/design_setup.tcl; default is logs_fc
LOGS_DIR := $(subst $\",,$(shell expand rm_setup/design_setup.tcl | grep "^set LOGS_DIR" | awk '{print $$3}'))

## EARLY_COMPILE_STAGE variable defined in rm_setup/fc_dp_setup.tcl; default is initial_map
EARLY_COMPILE_STAGE := $(subst $\",,$(shell expand rm_setup/fc_dp_setup.tcl | grep "^set EARLY_COMPILE_STAGE" | awk '{print $$3}'))

## STAGE and REPORT_PARALLEL_SUBMIT_COMMAND values are used by rm_summary target 
STAGE := $(filter-out rm_summary,$(MAKECMDGOALS))
REPORT_PARALLEL_SUBMIT_COMMAND := $(subst $\",,$(shell expand rm_setup/design_setup.tcl | grep "^set REPORT_PARALLEL_SUBMIT_COMMAND" | awk '{print $$3}'))

## Optional: Specify design library if you want backup step and clean step to use it
## CAUTION: if added, the clean step will delete it
DESIGN_LIB =

console:
	$(FC_EXEC)

setup:
	test -d $(LOGS_DIR) || mkdir $(LOGS_DIR)
	date > setup

init_design: setup
	rm -f init_design.varfile
	echo > init_design.varfile
	echo 'set rm_fp_pnr_flow true' >> init_design.varfile
	echo 'set REPORT_QOR false' >> init_design.varfile
	export RM_VARFILE=init_design.varfile; $(FC_EXEC) $(OPTIONS) -f ./rm_fc_scripts/init_design.tcl | tee -i $(LOGS_DIR)/init_design.log
	@test -f ./$@ || { echo "RM-error : a touch file for step $@ is expected at completion but not found. Please check $@.log for potential issues. Exiting ..."; exit 1; }

################################################################################################################
## Floorplanning embedded in compile_fusion flow 
################################################################################################################
ifneq ($(EARLY_COMPILE_STAGE),initial_map)
compile_logic: setup init_design 
	rm -f compile_logic.varfile
	echo > compile_logic.varfile
	echo 'set FC_STEP_LIST "pre_initial_map initial_map logic_opto"' >> compile_logic.varfile
	echo 'set rm_compile_logic true' >> compile_logic.varfile
	echo 'set CURRENT_STEP $${COMPILE_BLOCK_NAME}_logic_opto' >> compile_logic.varfile
	export RM_VARFILE=compile_logic.varfile; $(FC_EXEC) $(OPTIONS) -f ./rm_fc_scripts/compile.tcl |tee -i $(LOGS_DIR)/compile_logic.log
	@test -f ./$@ || { echo "RM-error : a touch file for step $@ is expected at completion but not found. Please check $@.log for potential issues. Exiting ..."; exit 1; }
else
compile_logic: setup init_design
	rm -f compile_logic.varfile
	echo > compile_logic.varfile
	echo 'set FC_STEP_LIST "pre_initial_map initial_map"' >> compile_logic.varfile
	echo 'set rm_compile_logic true' >> compile_logic.varfile
	echo 'set CURRENT_STEP $${COMPILE_BLOCK_NAME}_initial_map' >> compile_logic.varfile
	echo 'set SKIP_ABSTRACT_GENERATION true' >> compile_logic.varfile
	export RM_VARFILE=compile_logic.varfile; $(FC_EXEC) $(OPTIONS) -f ./rm_fc_scripts/compile.tcl |tee -i $(LOGS_DIR)/compile_logic.log
	@test -f ./$@ || { echo "RM-error : a touch file for step $@ is expected at completion but not found. Please check $@.log for potential issues. Exiting ..."; exit 1; }
endif

ifneq ($(EARLY_COMPILE_STAGE),initial_map)
create_floorplan: setup compile_logic
	rm -f create_floorplan.varfile
	echo > create_floorplan.varfile
	echo 'set PREVIOUS_STEP $${COMPILE_BLOCK_NAME}_logic_opto' >> create_floorplan.varfile
	export RM_VARFILE=create_floorplan.varfile; $(FC_EXEC) $(OPTIONS) -f ./rm_fc_dp_flat_scripts/create_floorplan.tcl | tee -i $(LOGS_DIR)/create_floorplan.log
	@test -f ./$@ || { echo "RM-error : a touch file for step $@ is expected at completion but not found. Please check $@.log for potential issues. Exiting ..."; exit 1; }
else
create_floorplan: setup compile_logic
	rm -f create_floorplan.varfile
	echo > create_floorplan.varfile
	echo 'set PREVIOUS_STEP $${COMPILE_BLOCK_NAME}_initial_map' >> create_floorplan.varfile
	export RM_VARFILE=create_floorplan.varfile; $(FC_EXEC) $(OPTIONS) -f ./rm_fc_dp_flat_scripts/create_floorplan.tcl | tee -i $(LOGS_DIR)/create_floorplan.log
	@test -f ./$@ || { echo "RM-error : a touch file for step $@ is expected at completion but not found. Please check $@.log for potential issues. Exiting ..."; exit 1; }
endif

create_power: setup create_floorplan
	$(FC_EXEC) $(OPTIONS) -f ./rm_fc_dp_flat_scripts/create_power.tcl | tee -i $(LOGS_DIR)/create_power.log
	@test -f ./$@ || { echo "RM-error : a touch file for step $@ is expected at completion but not found. Please check $@.log for potential issues. Exiting ..."; exit 1; }

place_pins: setup create_power
	$(FC_EXEC) $(OPTIONS) -f ./rm_fc_dp_flat_scripts/place_pins.tcl | tee -i $(LOGS_DIR)/place_pins.log
	@test -f ./$@ || { echo "RM-error : a touch file for step $@ is expected at completion but not found. Please check $@.log for potential issues. Exiting ..."; exit 1; }

ifneq ($(EARLY_COMPILE_STAGE),initial_map)
compile_final: setup place_pins
	rm -f compile_final.varfile
	echo > compile_final.varfile
	echo 'set FC_STEP_LIST "insert_dft initial_place initial_drc initial_opto final_place final_opto"' >> compile_final.varfile
	echo 'set rm_compile_final true' >> compile_final.varfile
	echo 'set PREVIOUS_STEP $${PLACE_PINS_BLOCK_NAME}' >> compile_final.varfile
	echo 'set CURRENT_STEP $${COMPILE_BLOCK_NAME}' >> compile_final.varfile
	export RM_VARFILE=compile_final.varfile; $(FC_EXEC) $(OPTIONS) -f ./rm_fc_scripts/compile.tcl |tee -i $(LOGS_DIR)/compile_final.log
	@test -f ./$@ || { echo "RM-error : a touch file for step $@ is expected at completion but not found. Please check $@.log for potential issues. Exiting ..."; exit 1; }
else
compile_final: setup place_pins
	rm -f compile_final.varfile
	echo > compile_final.varfile
	echo 'set FC_STEP_LIST "logic_opto insert_dft initial_place initial_drc initial_opto final_place final_opto"' >> compile_final.varfile
	echo 'set rm_compile_final true' >> compile_final.varfile
	echo 'set PREVIOUS_STEP $${PLACE_PINS_BLOCK_NAME}' >> compile_final.varfile
	echo 'set CURRENT_STEP $${COMPILE_BLOCK_NAME}' >> compile_final.varfile
	export RM_VARFILE=compile_final.varfile; $(FC_EXEC) $(OPTIONS) -f ./rm_fc_scripts/compile.tcl |tee -i $(LOGS_DIR)/compile_final.log
	@test -f ./$@ || { echo "RM-error : a touch file for step $@ is expected at completion but not found. Please check $@.log for potential issues. Exiting ..."; exit 1; }
endif
################################################################################################################

clock_opt_cts: setup compile_final
	$(FC_EXEC) $(OPTIONS) -f ./rm_fc_scripts/clock_opt_cts.tcl | tee -i $(LOGS_DIR)/clock_opt_cts.log
	@test -f ./$@ || { echo "RM-error : a touch file for step $@ is expected at completion but not found. Please check $@.log for potential issues. Exiting ..."; exit 1; }

clock_opt_opto: setup clock_opt_cts
	$(FC_EXEC) $(OPTIONS) -f ./rm_fc_scripts/clock_opt_opto.tcl | tee -i $(LOGS_DIR)/clock_opt_opto.log
	@test -f ./$@ || { echo "RM-error : a touch file for step $@ is expected at completion but not found. Please check $@.log for potential issues. Exiting ..."; exit 1; }

route_auto: setup clock_opt_opto
	$(FC_EXEC) $(OPTIONS) -f ./rm_fc_scripts/route_auto.tcl | tee -i $(LOGS_DIR)/route_auto.log
	@test -f ./$@ || { echo "RM-error : a touch file for step $@ is expected at completion but not found. Please check $@.log for potential issues. Exiting ..."; exit 1; }

route_opt: setup route_auto
	$(FC_EXEC) $(OPTIONS) -f ./rm_fc_scripts/route_opt.tcl | tee -i $(LOGS_DIR)/route_opt.log
	@test -f ./$@ || { echo "RM-error : a touch file for step $@ is expected at completion but not found. Please check $@.log for potential issues. Exiting ..."; exit 1; }

chip_finish: setup route_opt
	$(FC_EXEC) $(OPTIONS) -f ./rm_fc_scripts/chip_finish.tcl | tee -i $(LOGS_DIR)/chip_finish.log
	@test -f ./$@ || { echo "RM-error : a touch file for step $@ is expected at completion but not found. Please check $@.log for potential issues. Exiting ..."; exit 1; }

icv_in_design: setup chip_finish
	$(FC_EXEC) $(OPTIONS) -f ./rm_fc_scripts/icv_in_design.tcl | tee -i $(LOGS_DIR)/icv_in_design.log
	@test -f ./$@ || { echo "RM-error : a touch file for step $@ is expected at completion but not found. Please check $@.log for potential issues. Exiting ..."; exit 1; }

all: icv_in_design
	date > all

# Remember to also set WRITE_DATA_FROM_BLOCK_NAME to your desired step as input; default is icv_in_design
write_data: setup 
	$(FC_EXEC) $(OPTIONS) -f ./rm_fc_scripts/write_data.tcl | tee -i $(LOGS_DIR)/write_data.log

## rm_summary target will run the rm_summary script that generates and refreshes a qor summary table 
## To use, submit the rm_summary target in parallel with the appropriate implementation Makefile target 
## make -j -f rm_setup/Makefile route_opt rm_summary
## Note: the rm_summary target should only be submitted in parallel with an implementation makefile target.
## Valid targets: init_design, compile or any substep of compile, clock_opt_cts, clock_opt_opto, route_auto, route_opt, endpoint_opt, timing_eco, icv_in_design, chip_finish 
ifeq ($(MAKECMDGOALS),rm_summary)
rm_summary:
	rm_utilities/rm_summary.py  > summary_rm.rpt
else ifneq ($(REPORT_PARALLEL_SUBMIT_COMMAND),)
rm_summary: 
	@until [ -f rpts_fc/$(STAGE)/report_done ] ; do \
                sleep 60 ; \
                rm_utilities/rm_summary.py  > summary_rm.rpt ; \
        done 
else
rm_summary: 
	@until [ -f $(STAGE) ] ; do \
                sleep 60 ; \
                rm_utilities/rm_summary.py  > summary_rm.rpt ; \
        done
endif

################################################################################################################
## Optional for Flat Synthesis and P&R 
################################################################################################################
# route_opt PBA-CCD targeted optimization
endpoint_opt: route_opt
	$(FC_EXEC) $(OPTIONS) -f ./rm_fc_scripts/endpoint_opt.tcl | tee -i $(LOGS_DIR)/endpoint_opt.log

# Timing Closure ECO flow
# The timing closure ECO target supports both eco_opt and a user provided change file.  This is controlled via
# the PT_ECO_CHANGE_FILE variable in fc_setup.tcl.  If filler cells or metal fill exists in the source design,
# they are automatically reinserted after the ECO.
timing_eco: setup
	$(FC_EXEC) $(OPTIONS) -f ./rm_fc_scripts/timing_eco.tcl | tee -i $(LOGS_DIR)/timing_eco.log

# Functional ECO flow
# The functional ECO target supports both freeze_silicon and MPI.  If filler cells or metal fill exists in the 
# source design, they are automatically reinserted after the ECO.  It is recommended that functional ECOs are 
# followed by a timing closure ECO.
functional_eco: setup
	$(FC_EXEC) $(OPTIONS) -f ./rm_fc_scripts/functional_eco.tcl | tee -i $(LOGS_DIR)/functional_eco.log

# Redhawk in-design analysis
# Specify the starting block using the REDHAWK_IN_DESIGN_PNR_FROM_BLOCK_NAME variable in design_setup.tcl
redhawk_in_design_pnr: setup
	$(FC_EXEC) $(OPTIONS) -f ./rm_fc_scripts/redhawk_in_design_pnr.tcl | tee -i $(LOGS_DIR)/redhawk_in_design_pnr.log

# RedHawk-SC in-design analysis
# Specify the starting block using the REDHAWK_IN_DESIGN_PNR_FROM_BLOCK_NAME variable in design_setup.tcl
rhsc_in_design_pnr: setup
	$(FC_EXEC) $(OPTIONS) -f ./rm_fc_scripts/rhsc_in_design_pnr.tcl | tee -i $(LOGS_DIR)/rhsc_in_design_pnr.log

# Formality
fm_fc_compile.varfile : setup
	echo '' > fm_fc_compile.varfile
	echo 'set FM_LINK_LIBRARY $$LINK_LIBRARY' >> fm_fc_compile.varfile
	echo 'set FM_SVF_FILES " \
	  ./outputs_fc/init_design.svf \
	  ./outputs_fc/compile_init.svf \
	  ./outputs_fc/compile_pre_map.svf \
	  ./outputs_fc/compile_initial_map.svf \
	  ./outputs_fc/compile_logic_opto.svf \
	  ./outputs_fc/compile_insert_dft.svf \
	  ./outputs_fc/compile.svf \
	  "' >> fm_fc_compile.varfile
	echo 'set FM_IMP_NDM_BLOCK compile' >> fm_fc_compile.varfile

fm_fc_compile: fm_fc_compile.varfile
	export RM_VARFILE=fm_fc_compile.varfile ; $(FM_EXEC) $(OPTIONS) -f ./rm_fc_scripts/fm_r2g.tcl | tee -i $(LOGS_DIR)/fm_fc_compile.log
	date > fm_fc_compile


fm_fc_synpnr.varfile : setup
	echo '' > fm_fc_synpnr.varfile
	echo 'set FM_LINK_LIBRARY $$LINK_LIBRARY' >> fm_fc_synpnr.varfile
	echo 'set FM_SVF_FILES " \
	  ./outputs_fc/init_design.svf \
	  ./outputs_fc/compile_init.svf \
	  ./outputs_fc/compile_pre_map.svf \
	  ./outputs_fc/compile_initial_map.svf \
	  ./outputs_fc/compile_logic_opto.svf \
	  ./outputs_fc/compile_insert_dft.svf \
	  ./outputs_fc/compile.svf \
	  ./outputs_fc/clock_opt_cts.svf \
	  ./outputs_fc/clock_opt_opto.svf \
	  ./outputs_fc/route_auto.svf \
	  ./outputs_fc/route_opt.svf \
	  "' >> fm_fc_synpnr.varfile
	echo 'set FM_IMP_NDM_BLOCK write_data' >> fm_fc_synpnr.varfile

fm_fc_synpnr: fm_fc_synpnr.varfile
	export RM_VARFILE=fm_fc_synpnr.varfile ; $(FM_EXEC) $(OPTIONS) -f ./rm_fc_scripts/fm_r2g.tcl | tee -i $(LOGS_DIR)/fm_fc_synpnr.log
	date > fm_fc_synpnr

# Alternate FM targets for the flow
fm_fc_clock_opt_cts.varfile : setup
	echo '' > fm_fc_clock_opt_cts.varfile
	echo 'set FM_LINK_LIBRARY $$LINK_LIBRARY' >> fm_fc_clock_opt_cts.varfile
	echo 'set FM_SVF_FILES " \
	  ./outputs_fc/init_design.svf \
	  ./outputs_fc/compile_init.svf \
	  ./outputs_fc/compile_pre_map.svf \
	  ./outputs_fc/compile_initial_map.svf \
	  ./outputs_fc/compile_logic_opto.svf \
	  ./outputs_fc/compile_insert_dft.svf \
	  ./outputs_fc/compile.svf \
	  ./outputs_fc/clock_opt_cts.svf \
	  "' >> fm_fc_clock_opt_cts.varfile
	echo 'set FM_REF_NDM_BLOCK compile' >> fm_fc_clock_opt_cts.varfile
	echo 'set FM_IMP_NDM_BLOCK clock_opt_cts' >> fm_fc_clock_opt_cts.varfile

fm_fc_clock_opt_cts: fm_fc_clock_opt_cts.varfile
	export RM_VARFILE=fm_fc_clock_opt_cts.varfile ; $(FM_EXEC) $(OPTIONS) -f ./rm_fc_scripts/fm_r2g.tcl | tee -i $(LOGS_DIR)/fm_fc_clock_opt_cts.log
	date > fm_fc_clock_opt_cts

# Verification Compiler Low Power Static Signoff (VC LP)
vc_lp: setup write_data
	$(VC_LP_EXEC) -f ./rm_fc_scripts/vc_lp.tcl | tee -i $(LOGS_DIR)/vc_lp.log

################################################################################################################
# Utilities
################################################################################################################
# Generates a summary report and csv file after any stage of the flow. 
# Running it multiple times will overwrite previous reports with the new report.
summary: setup
	$(FC_EXEC) $(OPTIONS) -f ./rm_fc_scripts/summary.tcl | tee -i $(LOGS_DIR)/summary.log

##Backup
BACKUP  = BACKUP.`date "+%m_%d_%H_%M"`
backup:
	rm -rf $(BACKUP)
	mkdir -p $(BACKUP)
	cp -rf $(DESIGN_LIB) $(LOGS_DIR) $(BACKUP)

##Clean
clean:
	rm -f setup init_design compile_logic create_floorplan create_power place_pins compile_final place_opt clock_opt_cts clock_opt_opto route_auto route_opt chip_finish icv_in_design write_data all endpoint_opt timing_eco functional_eco redhawk_in_design_pnr rhsc_in_design_pnr fm_g2g fm_r2g vc_lp

clean_all: clean
	rm -rf $(LOGS_DIR) $(DESIGN_LIB)

## View a saved block in an interactive session
## view target start
## Required input : VIEW_BLOCK_NAME
## 1. Specify VIEW_BLOCK_NAME with a block name, either in the <design name>/<label> format, such as "RISC_CORE/init_design", or without using a label, such as "test1"
##    Note that RM's saved block format is always $DESIGN_NAME/<stage name>. So if the DESIGN_NAME is RISC_CORE and the stage is init_design, and you want to open the final saved block from this task,
##    you should specify RISC_CORE/init_design as the VIEW_BLOCK_NAME 
## 2. It's recommended to specify the value of VIEW_BLOCK_NAME when running make so there's no edit needed in the makefile. Here is the usage example: 
##    make -f rm_setup/Makefile view VIEW_BLOCK_NAME=RISC_CORE/init_design
##    where view is the makefile target, RISC_CORE/init_design is the name of the saved block which you want to open, 
##    and VIEW_BLOCK_NAME=RISC_CORE/init_design is the syntax to specify a value for VIEW_BLOCK_NAME when running make
## view target end
VIEW_BLOCK_NAME =
VIEW_TIMESTAMP = $(shell date +%m_%d_%H_%M_%S)

ifneq ($(VIEW_BLOCK_NAME),)
view: 
	rm -f view.varfile; echo > view.varfile
	echo 'set VIEW_BLOCK_NAME "${VIEW_BLOCK_NAME}"' >> view.varfile
	echo 'set VIEW_TIMESTAMP "${VIEW_TIMESTAMP}"' >> view.varfile
	export RM_VARFILE=view.varfile; $(FC_EXEC) $(OPTIONS) -f ./rm_fc_scripts/view.tcl | tee -i $(LOGS_DIR)/view_${VIEW_TIMESTAMP}.log
else
view:
	@echo 'RM-error : VIEW_BLOCK_NAME is null. To use view, please specify a valid value for VIEW_BLOCK_NAME.'
	@echo 'RM-error : For example, make -f rm_setup/Makefile view VIEW_BLOCK_NAME=RISC_CORE/route_opt ,where view is the makefile target, RISC_CORE/route_opt is the name of the saved block which you want to open, and VIEW_BLOCK_NAME=RISC_CORE/route_opt is the syntax to specify a value for a makefile variable when running make'
endif
## view target end

